## Correcci√≥n y Eficiencia: 


## CORRECCI√ìN: üìå‚Äã
 
  Un programa se considera eficiente si:
  ‚úîÔ∏è‚Äã Realiza la tarea buscada de acuerdo a sus especificaciones.

  ## T√©cnicas para la correci√≥n de programas: 
    ü™ß TESTING: El testing es el proceso de verificar que un programa o sistema funcione correctamente. Consiste en ejecutar          el software para detectar errores o fallos, asegurando que el c√≥digo cumpla con los requisitos especificados. Se               eval√∫an los casos limites del algoritmo.

    üêõ DEBUGGING: Es el proceso de descubrir y reparar la causa del error. Se dise√±an y aplican pruebas adicionales para              conocer y resolver la naturaleza del error. Tambi√©n se suelen agregar sentencias adicionales al programa para                  monitorear su comportamiento en determinados puntos de la ejecuci√≥n.

    üì£ WALKTHROUGH: Es recorrer el programa frente a una audiencia.

    ‚òëÔ∏è‚Äã VERIFICACI√ìN: Verificar un programa significa controlar las pre y post condiciones del mismo.

    

_______________________________________________________________________________________



## EFICIENCIA: üìå‚Äã

   Una vez se termina un algoritmo y se decide que es correcto, el proximo paso es determinar la eficiencia del mismo.

   ‚è≥‚Äã El analisis de la eficiencia estudia el tiempo que tarda un algoritmo en ejecutarse y la memoria que requiere. 

   ‚ùó Siempre que los valores para medir la eficiencia cambien segun los valores de entrada(por ejemplo, cortar un bucle a           partir de un dato ingresado por teclado), se deben evaluar los casos limites/peores casos del algoritmo.

    CONSIDERACIONES PARA MEDIR LA EFICIENCIA:
    Una instrucci√≥n elemental equivale a 1UT.

    EJEMPLOS:
    ‚óæ Algoritmo de tiempo constante:
    aux:=4; //T(1) = 1UT
    aux:= aux * 5; //T(2) multiplicaci√≥n+asignacion= 2 UT
    xd:=aux; //T(3) = 1UT
    //TOTAL: 4UT

    ___________________________________________________

     ‚óæ Con condicional IF:
    aux:=49; //T(1) = 1UT
    aux:= aux * 5; //T(2) = 2 UT
    if (aux > 45) then begin  //Como se eval√∫a siempre el peor caso es necesario suponer que se va a entrar al else -> Evaluar     condici√≥n del IF (1UT)
    temp:=aux-5; //Resta + asignaci√≥n 2UT
    x:=temp+aux+2; //Suma+resta+asignaci√≥n 3UT 
                  //T(3)=1+2+3=6UT
    end;
    x:=x*10; T(4)=2UT
    //TOTAL: 11UT

    ___________________________________________________

    ‚óæ Con condicional ELSE:
     Es exactamente igual que el if pero se debe evaluar antes si el calculo de memoria se va a hacer siguiendo el if o             siguiendo el else. Se debe hacer por la rama que m√°s UT lleve.

    ___________________________________________________

    ‚óæ Con condicional ELSE:
     Es exactamente igual que el if pero se debe evaluar antes si el calculo de memoria se va a hacer siguiendo el if o             siguiendo el else. Se debe hacer por la rama que m√°s UT lleve.


